package main

import (
	"flag"
	"fmt"
)

// putBit делает всю работу по заданию бита
func putBit(input int64, bitIndex uint, bitValue bool) int64 {
	// для расчёта нам нужно число, которое в 2ичном виде будет последовательностью нулей с 1 где-то посередине,
	// в том месте, где нам надо задать бит
	//
	// использовать нули для цифр, которые не нужно трогать, и единицу для изменяемого разряда очень удобно:
	//
	// &^	оставит остальные разряды как есть, проводя поразрядно D & 1,
	//		где D - значение бита в input, 1 - это инвертированный 0
	//
	// |	оставит остальные разряды как есть, проводя поразрядно D | 0,
	//		где 1 будет получено только в случае, когда бит уже равен 1, иначе 0
	//
	//	при этом &^	задаст значение нужного бита в 0, так как при любом D: D & 0 = 0
	//	при этом |	задаст значение нужного бита в 1, так как при любом D: D | 1 = 1
	//
	//	остаётся использовать нужный оператор в зависимости от значения бита, которое нужно получить

	mask := int64(1 << (bitIndex - 1))
	if bitValue {
		return input | mask
	}
	return input &^ mask
}

func main() {
	nFlag := flag.Int64("n", 168732, "input int64 number")
	iFlag := flag.Uint("i", 5, "bit number from 1 to 64")
	bFlag := flag.Bool("b", false, "bit value")
	flag.Parse()

	n := *nFlag
	i := *iFlag
	b := *bFlag

	output := putBit(n, i, b)
	fmt.Printf("(-i)\tbit index:\t%d\n(-b)\tbit value:\t%v\n(-n)\tinput:\t%d\n\tresult:\t%d\n\ninput:\t%064b\noutput:\t%064b\n",
		i, b, n, output, n, output)

	/*
		(-i)    bit index:      5
		(-b)    bit value:      false
		(-n)    input:  168732
		        result: 168716

		input:  0000000000000000000000000000000000000000000000101001001100011100
		output: 0000000000000000000000000000000000000000000000101001001100001100
	*/
}
